<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JS八股文自整合通俗易懂版上 | hexo</title><meta name="author" content="李贝贝"><meta name="copyright" content="李贝贝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、数据类型1. JavaScript有哪些数据类型，它们的区别？JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中新增的数据类型：  Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="JS八股文自整合通俗易懂版上">
<meta property="og:url" content="http://example.com/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/index.html">
<meta property="og:site_name" content="hexo">
<meta property="og:description" content="一、数据类型1. JavaScript有哪些数据类型，它们的区别？JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中新增的数据类型：  Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/picture/touxiang.jpeg">
<meta property="article:published_time" content="2025-07-22T12:00:05.913Z">
<meta property="article:modified_time" content="2025-07-22T12:24:55.146Z">
<meta property="article:author" content="李贝贝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/picture/touxiang.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JS八股文自整合通俗易懂版上",
  "url": "http://example.com/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/",
  "image": "http://example.com/picture/touxiang.jpeg",
  "datePublished": "2025-07-22T12:00:05.913Z",
  "dateModified": "2025-07-22T12:24:55.146Z",
  "author": [
    {
      "@type": "Person",
      "name": "李贝贝",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JS八股文自整合通俗易懂版上',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(picture/top1.jpeg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(picture/top1.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">JS八股文自整合通俗易懂版上</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JS八股文自整合通俗易懂版上</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-22T12:00:05.913Z" title="Created 2025-07-22 20:00:05">2025-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-07-22T12:24:55.146Z" title="Updated 2025-07-22 20:24:55">2025-07-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p>
<ul>
<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p>JavaScript中检测数据类型的方式主要有四种，各有特点：</p>
<ol>
<li>typeof</li>
</ol>
<ul>
<li>直接用 typeof 变量 判断，能识别Number、Boolean、String、Undefined等原始类型，以及Function。</li>
<li>局限：数组、对象、null都会被判断为 object ，无法区分。</li>
</ul>
<ol start="2">
<li>instanceof</li>
</ol>
<ul>
<li>用 变量 instanceof 类型 判断，能正确识别数组、函数、对象等引用类型（如 [] instanceof Array 返回true）。</li>
<li>局限：不能判断基本数据类型（如 2 instanceof Number 返回false）。</li>
</ul>
<ol start="3">
<li>constructor</li>
</ol>
<ul>
<li>通过 变量.constructor &#x3D;&#x3D;&#x3D; 类型 判断，可识别原始类型和引用类型（如 (2).constructor &#x3D;&#x3D;&#x3D; Number 返回true）。</li>
<li>局限：若修改了对象的原型，可能导致判断不准确。</li>
</ul>
<ol start="4">
<li>Object.prototype.toString.call()</li>
</ol>
<ul>
<li><p>用 Object.prototype.toString.call(变量) 判断，能精准识别所有数据类型（包括null、undefined等）。</p>
</li>
<li><p>原理：调用Object原型上的toString方法，避免其他类型重写的toString干扰，返回准确的类型信息。</p>
</li>
</ul>
<h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><p>判断一个对象是不是数组，有以下几种方式：</p>
<ul>
<li><p>通过Object.prototype.toString.call()做判断</p>
<p>Object.prototype.toString.call(obj).slice(8,-1) &#x3D;&#x3D;&#x3D; ‘Array’ ：通过调用Object原型的toString方法，截取结果判断。</p>
</li>
<li><p>通过原型链做判断</p>
<p>obj.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Array.prototype ：比较对象的原型与数组原型是否一致。</p>
</li>
<li><p>通过ES6的Array.isArray()做判断</p>
<p>Array.isArray(obj) ：ES6新增的方法，直接判断。</p>
</li>
<li><p>通过instanceof做判断</p>
<p>obj instanceof Array ：利用instanceof检查数组类型。</p>
</li>
<li><p>通过Array.prototype.isPrototypeOf(obj) ：判断数组原型是否是该对象的原型链上的对象。</p>
</li>
</ul>
<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><ul>
<li>都是基本数据类型，各只有一个值（undefined、null）。</li>
<li>含义不同：undefined表示“未定义”（变量声明后没赋值）；null表示“空对象”（常用于初始化可能返回对象的变量）。</li>
<li>比较差异： &#x3D;&#x3D;  比较时返回true， &#x3D;&#x3D;&#x3D;  比较时返回false。</li>
<li>注意：undefined可被当作变量名（不推荐），可用 void 0 安全获取。</li>
</ul>
<h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><ul>
<li>结果： typeof null  返回  object 。</li>
<li>原因：JavaScript早期设计中，数据用32位单元存储，包含类型标签。null的类型标签是 000 ，和对象（object）的标签相同，因此被误判为object，属于历史遗留问题。</li>
</ul>
<h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><ul>
<li><p>原理：判断构造函数的 prototype 是否在对象的原型链上。</p>
</li>
<li><p>简单实现：</p>
<p>function myInstanceof(left, right) {  &#x2F;&#x2F; 获取对象的原型</p>
<p>  let proto &#x3D; Object.getPrototypeOf(left)  &#x2F;&#x2F; 获取构造函数的 prototype 对象  </p>
<p>let prototype &#x3D; right.prototype;    &#x2F;&#x2F; 判断构造函数的 prototype 对象是否在对象的原型链上  while (true) { </p>
<p>   if (!proto) return false;    </p>
<p>if (proto &#x3D;&#x3D;&#x3D; prototype) return true;   </p>
<p> &#x2F;&#x2F; 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型    proto &#x3D; Object.getPrototypeOf(proto);</p>
<p>  }</p>
<p> }</p>
</li>
</ul>
<h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><ul>
<li><p>原因：JavaScript用64位双精度浮点数存储数字，0.1和0.2的二进制是无限循环小数，存储时会截断，导致相加后结果为 0.30000000000000004 ，不等于0.3。</p>
</li>
<li><p>让它们“相等”的办法：</p>
</li>
<li><p>用 toFixed(2) 保留两位小数（四舍五入）。</p>
</li>
<li><p>用误差范围判断：通过 Number.EPSILON （表示极小误差）检查两数差值是否小于该值，如：<br>function isEqual(a, b) {<br>return Math.abs(a - b) &lt; Number.EPSILON;<br>}<br>console.log(isEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true</p>
<h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3></li>
<li><p>isNaN：会先尝试把参数转成数字，转不成数字就返回true（比如非数字值也可能返回true，判断不够准确）。</p>
</li>
<li><p>Number.isNaN：先判断参数是否为数字，只有是数字且为NaN时才返回true，不做类型转换，判断更准确。</p>
<h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3></li>
<li><p>null → “null”，undefined → “undefined”；</p>
</li>
<li><p>true → “true”，false → “false”；</p>
</li>
<li><p>数字直接转，极小&#x2F;极大数字用指数形式；</p>
</li>
<li><p>Symbol只能显式转字符串，隐式转换会报错；</p>
</li>
<li><p>对象：默认调用Object.prototype.toString()返回”[object Object]”，有自定义toString()则用其返回值。</p>
</li>
</ul>
<h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul>
<li>undefined → NaN，null → 0；</li>
<li>true → 1，false → 0；</li>
<li>字符串：用Number()转换，含非数字则为NaN，空字符串为0；</li>
<li>Symbol转数字会报错；</li>
<li>对象&#x2F;数组：先转成基本类型（先调valueOf()，不行再调toString()），再按以上规则转数字，若都不返回基本类型则报错。</li>
</ul>
<h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><ul>
<li>假值（转换后为false）：undefined、null、false、+0、-0、NaN、””；</li>
<li>除假值外的所有值都是真值（转换后为true）。</li>
</ul>
<h3 id="16-Object-is-与比较操作符-和-的区别？"><a href="#16-Object-is-与比较操作符-和-的区别？" class="headerlink" title="16. Object.is()与比较操作符 &#x3D;&#x3D;&#x3D;和&#x3D;&#x3D; 的区别？"></a>16. Object.is()与比较操作符 &#x3D;&#x3D;&#x3D;和&#x3D;&#x3D; 的区别？</h3><p>三者都是用于判断相等性的方式，核心区别如下：</p>
<ul>
<li><p>&#x3D;&#x3D;（双等号）：会先对两边不同类型的值进行强制类型转换，再比较转换后的值是否相等。</p>
</li>
<li><p>&#x3D;&#x3D;&#x3D;（三等号）：不进行类型转换，若两边类型不同直接返回false；类型相同时才比较值是否相等。</p>
</li>
<li><p>Object.is()：大部分情况和&#x3D;&#x3D;&#x3D;一致，但特殊处理两种情况：-0和+0被视为不相等，两个NaN被视为相等。</p>
</li>
</ul>
<h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>JavaScript的隐式类型转换，核心是通过 ToPrimitive 方法先将值（尤其是对象）转为基本类型，再按运算符规则转换：</p>
<ol>
<li>ToPrimitive方法（对象转基本类型）</li>
</ol>
<ul>
<li>作用：将对象转为基本类型，默认根据对象类型确定转换方向（ type ）。</li>
<li>Date对象默认 type 为 string ：先调用 toString() ，不行再用 valueOf() 。</li>
<li>其他对象默认 type 为 number ：先调用 valueOf() ，不行再用 toString() 。</li>
<li>若都返回对象，则报错。</li>
</ul>
<ol start="2">
<li>不同运算符的转换规则</li>
</ol>
<p>（1） + 运算符</p>
<ul>
<li>两边有一个是字符串：都转为字符串拼接（如 1 + ‘2’ → ‘12’ ）。</li>
<li>其他情况：都转为数字相加（如 1 + false → 1 ）。</li>
</ul>
<p>（2） - 、 * 、 &#x2F; 运算符</p>
<ul>
<li>两边都转为数字计算（如 ‘3’ * 2 → 6 ， ‘a’ &#x2F; 1 → NaN ）。</li>
</ul>
<p>（3） &#x3D;&#x3D; 运算符</p>
<ul>
<li>两边尽量转为数字比较（如 ‘0’ &#x3D;&#x3D; false → true ，因都转成0）。</li>
</ul>
<p>（4） &lt; 、 &gt; 比较符</p>
<ul>
<li>两边都是字符串：按字母顺序比较（如 ‘a’ &lt; ‘b’ → true ）。</li>
<li>其他情况：转为数字比较（如 ‘12’ &lt; 13 → true ）。</li>
</ul>
<ol start="3">
<li>对象参与运算的过程</li>
</ol>
<p>先通过 ToPrimitive 转成基本类型，再按上述规则转换。例如：</p>
<ul>
<li>{} + {} ：对象转字符串 “[object Object]” ，结果为 “[object Object][object Object]” 。</li>
<li>{} &gt; 2 ：对象转数字 NaN ， NaN &gt; 2 返回 false 。</li>
</ul>
<h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><ul>
<li>块级作用域：let、const 受  { }  限制（块内有效），var 不受（可能污染外部）。</li>
<li>变量提升：var 会提前“声明”（可在声明前用，值为 undefined），let、const 不会（声明前用报错）。</li>
<li>全局属性：var 声明的全局变量会成为 window&#x2F;global 的属性，let、const 不会。</li>
<li>重复声明：var 允许重复声明（后值覆盖前值），let、const 不允许（直接报错）。</li>
<li>暂时性死区：let、const 声明前的区域，变量不可用；var 无此限制。</li>
<li>初始值：const 必须初始化赋值，var、let 可以不赋。</li>
<li>值修改：var、let 可以改值，const 声明后不能改值（指向的内存地址固定）。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>var</strong></th>
<th><strong>let</strong></th>
<th><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否有块级作用域</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否存在变量提升</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否添加全局属性</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>能否重复声明变量</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否存在暂时性死区</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否必须设置初始值</td>
<td>×</td>
<td>×</td>
<td>✔️</td>
</tr>
<tr>
<td>能否改变指针指向</td>
<td>✔️</td>
<td>✔️</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>可以。const只保证变量指向的内存地址不变（即不能给变量重新赋值另一个对象），但对象本身的属性可以修改。比如  const obj &#x3D; {a: 1}; obj.a &#x3D; 2  是允许的。</p>
<h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>会报错。因为箭头函数没有prototype，也不能绑定this，而new操作需要依赖这些特性（如将新对象的__proto__指向构造函数的prototype），所以箭头函数不能当构造函数用，无法被new。</p>
<h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><ol start="4">
<li>箭头函数与普通函数的区别</li>
</ol>
<p>面试回答时可以分点说，重点突出核心差异，附简单代码辅助理解：</p>
<ol>
<li><p>语法更简洁<br>箭头函数可省略  function 、括号（单参数时）、大括号（单语句返回时）。<br>&#x2F;&#x2F; 普通函数<br>function add(a, b) { return a + b; }<br>&#x2F;&#x2F; 箭头函数<br>const add &#x3D; (a, b) &#x3D;&gt; a + b; &#x2F;&#x2F; 简洁写法</p>
</li>
<li><p>this指向不同</p>
</li>
</ol>
<ul>
<li>普通函数： this  随调用方式变化（谁调用指向谁，默认指向全局）。</li>
<li>箭头函数：无自己的  this ，继承外层作用域的  this （定义时就固定，无法改变）。</li>
</ul>
<p>const obj &#x3D; {<br>  name: ‘obj’,<br>  fn1: function() { console.log(this.name); }, &#x2F;&#x2F; 普通函数：this指向obj<br>  fn2: () &#x3D;&gt; { console.log(this.name); } &#x2F;&#x2F; 箭头函数：this指向外层（全局，此处可能为undefined）<br>};<br>obj.fn1(); &#x2F;&#x2F; 输出 ‘obj’<br>obj.fn2(); &#x2F;&#x2F; 输出 undefined（浏览器中可能是window.name，通常为空）</p>
<p>理由：这段代码的关键是理解 普通函数和箭头函数的this指向规则，咱们一步步拆：</p>
<ol>
<li>先看  obj.fn1()  为什么输出  ‘obj’</li>
</ol>
<p> fn1  是普通函数（用  function  定义），它的  this  指向 调用它的对象。<br>这里  obj.fn1()  是  obj  调用了  fn1 ，所以  this  就指向  obj  本身。<br> obj  里有  name: ‘obj’ ，因此  console.log(this.name)  输出  ‘obj’ 。</p>
<ol start="2">
<li>再看  obj.fn2()  为什么输出  undefined</li>
</ol>
<p> fn2  是箭头函数，它没有自己的  this ，this继承自定义时的外层作用域。</p>
<ul>
<li>fn2  定义在  obj  对象里，但对象的大括号  {}  不算“作用域”，它的外层作用域是 全局作用域（比如浏览器里的  window ）。</li>
<li>全局作用域中并没有定义  name  属性（或者说  window.name  默认是空&#x2F;undefined），所以  this.name  就是  undefined 。</li>
</ul>
<p>简单说：</p>
<ul>
<li>普通函数的  this  是“谁调用，指向谁”（这里  obj  调用  fn1 ，所以  this  是  obj ）。</li>
<li>箭头函数的  this  是“定义时抓外层的this”（这里外层是全局，全局没  name ，所以输出  undefined ）。</li>
</ul>
<ol start="3">
<li><p>不能用call&#x2F;apply&#x2F;bind改变this<br>箭头函数的  this  固定，这些方法无法修改其指向。<br>const fn &#x3D; () &#x3D;&gt; { console.log(this); };<br>fn.call({x: 1}); &#x2F;&#x2F; 仍指向外层this（如window），不会指向{x:1}</p>
</li>
<li><p>不能作为构造函数（不能用new）<br>箭头函数无  prototype ，且  this  固定，无法实例化对象。<br>const Fn &#x3D; () &#x3D;&gt; {};<br>new Fn(); &#x2F;&#x2F; 报错：Fn is not a constructor</p>
</li>
<li><p>无arguments对象<br>箭头函数访问  arguments  会取外层函数的，普通函数有自己的  arguments 。<br>function fn() {<br> const arrow &#x3D; () &#x3D;&gt; console.log(arguments[0]); &#x2F;&#x2F; 取fn的arguments<br> arrow();<br>}<br>fn(10); &#x2F;&#x2F; 输出 10</p>
</li>
<li><p>其他</p>
</li>
</ol>
<ul>
<li>箭头函数无  prototype  属性；</li>
<li>不能用  yield （不能作为Generator函数）。</li>
</ul>
<ol start="5">
<li>箭头函数的this指向哪里？</li>
</ol>
<p>直接说核心：<br>箭头函数没有自己的this，它的this继承自定义时所在的外层作用域的this，且一旦确定就不会改变。<br>可结合代码举例（同上面第2点的代码，简洁明了）。</p>
<p><strong>举例：</strong></p>
<p>大概率会！面试官可能会结合具体场景让你写代码对比，比如考  this  指向差异、简洁语法的应用，或者判断箭头函数能不能用在某个场景（比如构造函数、对象方法）。</p>
<p>举个常见的面试题例子，比如让你解释下面代码的输出结果：</p>
<p>const obj &#x3D; {<br>  value: 10,<br>  getValue: function() {<br>    &#x2F;&#x2F; 普通函数<br>    setTimeout(function() { console.log(this.value); }, 0);<br>    &#x2F;&#x2F; 箭头函数<br>    setTimeout(() &#x3D;&gt; { console.log(this.value); }, 0);<br>  }<br>};<br>obj.getValue(); </p>
<p>答案是：第一个输出  undefined （普通函数this指向window），第二个输出  10 （箭头函数继承外层this，即obj）。</p>
<h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>这么说吧：箭头函数的this就像“借”来的，而且一借定终身。</p>
<p>比如你写箭头函数的时候，它会扭头看看自己“外面”是谁的<strong>外层作用域</strong>（地盘），然后把那个地盘的this拿过来当自己的，之后不管被谁调用、怎么调用，都不会换了。</p>
<p>举个例子：<br>你在小明的房间里写了个箭头函数，那这个箭头函数的this就永远是小明。哪怕后来把这个函数拿到小红家去用，它的this还是小明，不会变成小红。</p>
<p>而普通函数的this是“谁用算谁的”——小明用就是小明，小红用就是小红，很灵活。</p>
<p>箭头函数这种“借了不还”的特性，就是它this的核心特点啦~</p>
<h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>rest 参数（ …变量名 ）的作用很简单：<strong>把函数接收的多个零散参数，自动打包成一个数组。</strong></p>
<p>比如调用函数时传了  1, 2, 3, 4  这几个参数，用  …args  接收后， args  就变成  [1, 2, 3, 4] ，直接按数组方式处理（遍历、计算等）就行。</p>
<p>适合场景：当不确定函数会收到多少个参数时，用 rest 参数能统一收纳，比用  arguments  更方便（因为它本身就是数组，可直接用数组方法）。</p>
<p>例：</p>
<p>function sum(…nums) { &#x2F;&#x2F; nums 是打包后的数组<br>  return nums.reduce((a, b) &#x3D;&gt; a + b, 0); &#x2F;&#x2F; 直接用数组方法求和<br>}<br>sum(1, 2, 3); &#x2F;&#x2F; 6（nums 是 [1,2,3]）</p>
<h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>重点记模板字符串的用法和新增的字符串方法，面试时说清核心功能即可：</p>
<ol>
<li>模板字符串（    反引号包裹）</li>
</ol>
<p>解决传统字符串拼接麻烦的问题，优势很直观：</p>
<ul>
<li><p>直接嵌入变量：用  ${变量名}  代替  +  拼接，更简洁。<br>const name &#x3D; ‘小明’;<br>&#x2F;&#x2F; 传统写法<br>const str1 &#x3D; ‘我叫’ + name + ‘，今年18岁’;<br>&#x2F;&#x2F; 模板字符串<br>const str2 &#x3D; <code>我叫$&#123;name&#125;，今年18岁</code>; &#x2F;&#x2F; 更清晰</p>
</li>
<li><p>保留格式：换行、空格会原样保留，适合写多行文本（比如HTML结构）。<br>const html &#x3D; &#96;</p>
<div>
  <p>这是一行文字</p >
</div>
`; // 输出时会保留换行和缩进
</li>
<li><p>支持表达式： ${}  里可以写简单计算、函数调用等。<br>const a &#x3D; 10, b &#x3D; 20;<br>const str &#x3D; <code>$&#123;a&#125; + $&#123;b&#125; = $&#123;a + b&#125;</code>; &#x2F;&#x2F; 输出 “10 + 20 &#x3D; 30”</p>
</li>
</ul>
<ol start="2">
<li>新增的字符串方法</li>
</ol>
<p>都是简化字符串操作的实用方法，返回布尔值或新字符串：</p>
<ul>
<li><p>includes(str)：判断字符串是否包含某子串（替代  indexOf &gt; -1 ）。<br>‘hello world’.includes(‘world’); &#x2F;&#x2F; true</p>
</li>
<li><p>startsWith(str)：判断是否以某子串开头。<br>‘hello world’.startsWith(‘hello’); &#x2F;&#x2F; true</p>
</li>
<li><p>endsWith(str)：判断是否以某子串结尾。<br>‘hello world’.endsWith(‘world’); &#x2F;&#x2F; true</p>
</li>
<li><p>repeat(n)：将字符串重复  n  次并返回。<br>‘hi’.repeat(3); &#x2F;&#x2F; “hihihi”</p>
</li>
</ul>
<p>这些功能主要是让字符串处理更简单、代码更易读，面试时举1-2个例子就能说明白~</p>
<h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p>简单说，new操作符就是帮我们自动做了四件事：</p>
<ul>
<li>造一个空对象</li>
<li>让这个对象的原型链连到构造函数的prototype上</li>
<li>把构造函数里的this换成这个新对象，执行构造函数（给对象加属性）</li>
<li>最后看构造函数返回啥：如果是简单值（比如数字、字符串），就返回新对象；如果是对象&#x2F;函数，就返回这个返回值</li>
</ul>
<p>代码里的 objectFactory 函数就是模拟这个过程，用它能像new一样创建对象</p>
<h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><ul>
<li>键的问题：Map只有自己加的键，Object可能有原型链上的默认键，容易冲突</li>
<li>键的类型：Map的键可以是任何东西（函数、对象等），Object的键只能是字符串或Symbol</li>
<li>顺序和数量：Map的键有顺序、能直接用size看数量；Object的键无序，数量得自己算</li>
<li>迭代和性能：Map能直接循环，增删频繁时更快；Object要先拿键才能循环，频繁增删性能一般</li>
</ul>
<h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>目的是让JS在页面加载后再加载，提升页面速度，主要方式：</p>
<ul>
<li><p>defer属性：脚本加载时不阻塞页面解析，文档解析完再按顺序执行</p>
</li>
<li><p>async属性：脚本异步加载，加载完立即执行，顺序不确定</p>
</li>
<li><p>动态创建script标签：等页面加载完成后，再通过JS创建标签引入脚本</p>
</li>
<li><p>setTimeout延迟：用定时器推迟脚本加载</p>
</li>
<li><p>放页面底部：让JS在页面其他内容加载后再加载</p>
</li>
</ul>
<h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><ul>
<li>定义：有length属性和索引属性（像数组），但不能直接用数组方法（如arguments、DOM查询结果）。</li>
<li>转数组方法：</li>
<li>Array.prototype.slice.call(类数组) </li>
<li>Array.prototype.splice.call(类数组, 0) </li>
<li>Array.prototype.concat.apply([], 类数组) </li>
<li>Array.from(类数组) （ES6方法，更简单）</li>
</ul>
<h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><p>数组的原生方法可以按功能分几类：</p>
<ul>
<li><p>转字符串： toString() （直接转）、 toLocalString() （本地化格式）、 join(‘分隔符’) （自定义分隔符）。</p>
</li>
<li><p>尾部操作： pop() （删最后一个元素，返回该元素）、 push(元素…) （加元素到末尾，返回新长度）。</p>
</li>
<li><p>首部操作： shift() （删第一个元素，返回该元素）、 unshift(元素…) （加元素到开头，返回新长度）。</p>
</li>
<li><p>排序： reverse() （反转数组）、 sort(比较函数) （排序，可自定义规则）。</p>
</li>
<li><p>连接&#x2F;截取： concat(数组&#x2F;元素) （拼接，不改变原数组）、 slice(开始, 结束) （截取部分，不改变原数组）。</p>
</li>
<li><p>增删改： splice(起始索引, 删几个, 加的元素…) （直接修改原数组）。</p>
</li>
<li><p>查找索引： indexOf(值) （从前往后找索引）、 lastIndexOf(值) （从后往前找）。</p>
</li>
<li><p>迭代： every() （全满足返回true）、 some() （有一个满足返回true）、 filter() （筛选符合条件的元素）、 map() （每个元素处理后返回新数组）、 forEach() （遍历执行函数）。</p>
</li>
<li><p>归并： reduce() （从左到右累计计算）、 reduceRight() （从右到左累计计算）。</p>
<h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3></li>
<li><p>原因：arguments是对象，有索引和length属性，像数组，但没有数组的forEach等方法，所以叫类数组。</p>
</li>
<li><p>遍历方式：</p>
</li>
<li><p>用数组方法+call： Array.prototype.forEach.call(arguments, 函数) </p>
</li>
<li><p>转数组后遍历： Array.from(arguments)  或  […arguments]  转成数组，再用数组方法遍历</p>
</li>
</ul>
<h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul>
<li>DOM：文档对象模型，把网页内容（如html、xml）当对象，提供操作内容的方法（比如增删元素）。</li>
<li>BOM：浏览器对象模型，把浏览器当对象，提供操作浏览器的方法（比如控制窗口、地址栏）。核心是window对象，DOM的document也是window的子对象。</li>
</ul>
<h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><ul>
<li><p>理解：有length和索引属性（像数组），但没有数组方法（如arguments、DOM查询结果）。</p>
</li>
<li><p>转数组方法：</p>
</li>
<li><p>通过 call 调用数组的 slice 方法来实现转换</p>
<p>Array.prototype.slice.call(类数组) </p>
</li>
<li><p>通过 call 调用数组的 splice 方法来实现转换</p>
<p>Array.prototype.splice.call(类数组, 0) </p>
<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<p>Array.prototype.concat.apply([], 类数组) </p>
<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<p>Array.from(类数组) （ES6，简单常用）</p>
</li>
</ul>
<h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><ul>
<li>理解：AJAX是异步JavaScript和XML的缩写，能通过JS异步请求服务器数据，不用刷新整个页面就能更新部分内容。</li>
<li>实现AJAX请求步骤：</li>
</ul>
<ol>
<li>创建 XMLHttpRequest 对象；</li>
<li>用 open() 设置请求方法、地址、是否异步；</li>
<li>监听 onreadystatechange 事件，当 readyState 为4（请求完成）且 status 为200（成功）时，处理返回数据；</li>
<li>用 send() 发送请求。</li>
</ol>
<ul>
<li>用Promise封装后，可通过 then() 和 catch() 更方便地处理成功和失败的情况。</li>
</ul>
<h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><ul>
<li>原因：JS执行前会先解析代码，创建执行上下文，提前处理变量和函数声明（变量设为 undefined ，函数定义好）。这样做是为了提高性能（解析一次即可）和增强容错性（允许先使用后声明）。</li>
<li>导致的问题：</li>
<li>变量被意外覆盖，比如函数内的变量提升可能覆盖外部变量；</li>
<li>循环中用 var 声明的变量会变成全局变量，循环结束后仍能访问（如 for 循环的 i ）。</li>
<li>ES6的 let 、 const 解决了这些问题，没有变量提升。</li>
</ul>
<hr>
<h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19. ES6模块与CommonJS模块有什么异同？"></a>19. <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>不同点</p>
<ul>
<li>引用方式：CommonJS是对模块的浅拷贝，引入后可以修改变量的指针指向（比如重新赋值）；ES6模块是对模块的引用，类似 const ，引入的接口是只读的，不能修改变量的指针指向，否则会报错。</li>
</ul>
<p>相同点</p>
<ul>
<li>无论是哪种模块，都能修改引入对象的内部属性值（比如对象里的属性、数组里的元素等）。</li>
</ul>
<h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><p>判断一个对象是否属于某个类，有三种方法：</p>
<ul>
<li>用instanceof：看构造函数的prototype是否在对象的原型链上，比如 obj instanceof 类 。</li>
<li>用constructor属性：对象的constructor指向构造函数，但这个属性能被修改，不太可靠。</li>
<li>用Object.prototype.toString()：适合判断内置类型（如数组、日期），能返回对象的具体类型信息。</li>
</ul>
<h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…in 和 for…of 的区别主要有这几点：</p>
<ul>
<li>取的值不同：for…in 拿到的是键名（比如数组的索引、对象的属性名）；for…of 拿到的是键值（数组里的元素、对象属性对应的值）。</li>
<li>遍历范围不同：for…in 会顺着原型链往上找，把父类的属性也遍历出来，性能较差；for…of 只遍历当前对象本身的内容。</li>
<li>适用场景不同：for…in 更适合遍历对象，不太适合数组；for…of 适合数组、字符串、Set 等，用起来更直观。</li>
</ul>
<h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><ul>
<li>forEach() ：遍历数组，对每个元素执行操作，不改变原数组，也没有返回值。</li>
<li>map() ：遍历数组，对每个元素处理后返回新数组，不改变原数组，可链式调用。</li>
<li>filter() ：过滤数组，返回符合条件的元素组成的新数组，可链式调用。</li>
<li>for…of ：遍历数组元素（或其他有迭代器的对象），同步执行，只返回元素值。</li>
<li>every() &#x2F; some() ： every() 判断所有元素是否符合条件（全符合才返回true）； some() 判断是否有元素符合条件（有一个符合就返回true）。</li>
<li>find() &#x2F; findIndex() ： find() 返回第一个符合条件的元素； findIndex() 返回其索引。</li>
<li>reduce() &#x2F; reduceRight() ： reduce() 从左到右累计处理数组； reduceRight() 从右到左。</li>
</ul>
<h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><ul>
<li>forEach ：只遍历执行操作，不返回新数组，也不改变原数组（但可手动修改元素内部值）。</li>
<li>map ：遍历后返回新数组（每个元素是处理后的结果），不改变原数组，适合链式操作。</li>
</ul>
<h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>原型和原型链：</p>
<ul>
<li><p>原型：一<strong>个对象，每个构造函数都有个 prototype 属性（原型对象）</strong>，里面存着该构造函数创建的所有实例能共享的属性和方法。比如用 Person 构造函数创建的人，都能共享 Person.prototype 里的 getName 方法。可解决构造函数资源浪费问题。</p>
</li>
<li><p>原型链：当访问对象的属性&#x2F;方法时，若自身没有，就会去它的原型对象里找；原型对象没有，就去原型的原型里找，一直找到最顶层的 Object.prototype ，这串链式查找关系就是原型链。</p>
<h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3></li>
<li><p>修改原型：给构造函数的 prototype 加属性&#x2F;方法（比如 Person.prototype.getName &#x3D; … ），新创建的实例能直接用，且实例的 <strong>proto</strong> 仍和构造函数的 prototype 对应。</p>
</li>
<li><p>重写原型：直接给 prototype 赋值新对象（比如 Person.prototype &#x3D; { … } ），此时实例的 constructor 会默认指向 Object ，需要手动改回 Person （ p.constructor &#x3D; Person ），才能保持对应关系。</p>
</li>
</ul>
<h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><ul>
<li><p>实例的 <strong>proto</strong> 指向构造函数的 prototype （比如 p.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Person.prototype ）。</p>
</li>
<li><p>构造函数原型的 <strong>proto</strong> ，最终会指向 Object.prototype （比如 Person.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype ），这是原型链的顶端。</p>
</li>
</ul>
<h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文&#x2F;作用域链&#x2F;闭包"></a>五、执行上下文&#x2F;作用域链&#x2F;闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><ul>
<li><p>定义：一个函数能访问另一个函数内部的变量，这个函数就是闭包（通常是在函数内部嵌套另一个函数）。</p>
</li>
<li><p>用途：</p>
</li>
<li><p>在函数外部访问函数内部的变量（比如创建私有变量）；</p>
</li>
<li><p>让函数执行完后，内部变量仍能被保留（不被垃圾回收）。</p>
</li>
<li><p>代码举例：<br>function outer() {<br>let a &#x3D; 10; &#x2F;&#x2F; 内部变量<br>function inner() { &#x2F;&#x2F; inner是闭包<br>  console.log(a); &#x2F;&#x2F; 访问outer的变量a<br>}<br>return inner;<br>}<br>const fn &#x3D; outer();<br>fn(); &#x2F;&#x2F; 输出10（外部通过闭包访问到了a）</p>
</li>
<li><p>经典面试题：解决循环中 setTimeout 打印相同值的问题<br>&#x2F;&#x2F; 问题：用var声明i，循环后所有定时器都打印6<br>for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) {<br>setTimeout(function() {<br>  console.log(i); &#x2F;&#x2F; 输出5个6<br>}, 1000);<br>}</p>
</li>
</ul>
<p>&#x2F;&#x2F; 解决方法1：用闭包固定i的值<br>for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) {<br>  (function(j) { &#x2F;&#x2F; 立即执行函数，j接收当前i的值<br>    setTimeout(function() {<br>      console.log(j); &#x2F;&#x2F; 输出1,2,3,4,5<br>    }, 1000);<br>  })(i);<br>}</p>
<p>&#x2F;&#x2F; 解决方法2：用let声明i（推荐，块级作用域）<br>for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) {<br>  setTimeout(function() {<br>    console.log(i); &#x2F;&#x2F; 输出1,2,3,4,5<br>  }, 1000);<br>}</p>
<h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><ul>
<li>作用域：变量能被访问的范围，分三种：</li>
<li>全局作用域：最外层的变量&#x2F;函数，整个程序都能访问（比如 window.a ）；</li>
<li>函数作用域：函数内部声明的变量，只有函数内可访问；</li>
<li>块级作用域： {} 内用 let&#x2F;const 声明的变量，只在块内有效（比如 for 循环内的 let i ）。</li>
<li>作用域链：当前作用域找不到变量时，会依次去父级作用域找，直到全局作用域，这串链条就是作用域链。<br>let a &#x3D; 1; &#x2F;&#x2F; 全局作用域<br>function outer() {<br>let b &#x3D; 2; &#x2F;&#x2F; outer作用域<br>function inner() {<br>  let c &#x3D; 3; &#x2F;&#x2F; inner作用域<br>  console.log(a + b + c); &#x2F;&#x2F; 找a（全局）、b（outer）、c（inner），形成作用域链<br>}<br>inner();<br>}<br>outer(); &#x2F;&#x2F; 输出6</li>
</ul>
<h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><ol start="3">
<li>对执行上下文的理解</li>
</ol>
<ul>
<li>定义：JS执行代码前的准备工作，会创建一个环境，包含变量、函数、 this 等信息。</li>
<li>类型：</li>
<li>全局执行上下文：整个程序只有一个，创建 window 对象， this 指向 window ；</li>
<li>函数执行上下文：每次调用函数时创建，包含 this 、 arguments 、函数内的变量&#x2F;函数。</li>
<li>执行流程：</li>
</ul>
<ol>
<li>创建阶段：绑定 this ，准备变量（变量设为 undefined ）、函数（提前定义）；</li>
<li>执行阶段：给变量赋值，执行代码。</li>
</ol>
<ul>
<li>执行上下文栈：函数调用时，其执行上下文压入栈顶，执行完后弹出，回到上一个上下文。<br>let global &#x3D; ‘全局变量’;<br>function fn1() {<br>console.log(‘fn1执行’);<br>fn2();<br>}<br>function fn2() {<br>console.log(‘fn2执行’);<br>}<br>fn1();<br>&#x2F;&#x2F; 执行栈流程：全局上下文入栈 → fn1调用，fn1上下文入栈 → fn2调用，fn2上下文入栈 → fn2执行完出栈 → fn1执行完出栈 → 全局上下文出栈</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">李贝贝</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/">http://example.com/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/picture/touxiang.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/22/CSS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88/" title="CSS八股文自整合通俗易懂版"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">CSS八股文自整合通俗易懂版</div></div><div class="info-2"><div class="info-item-1">1. CSS选择器及其优先级   选择器 格式 优先级权重    id选择器 #id 100   类选择器 #classname 10   属性选择器 a[ref&#x3D;“eee”] 10   伪类选择器 li:last-child 10   标签选择器 div 1   伪元素选择器 li:after 1   相邻兄弟选择器 h1+p 0   子选择器 ul&gt;li 0   后代选择器 li a 0   通配符选择器 * 0   对于选择器的优先级：  标签选择器、伪元素选择器：1 类选择器、伪类选择器、属性选择器：10 id 选择器：100 内联样式：1000  注意事项：  !important声明的样式的优先级最高； 如果优先级相同，则最后出现的样式生效； 继承得到的样式的优先级最低；  3....</div></div></div></a><a class="pagination-related" href="/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8B/" title="JS八股文自整合通俗易懂版下"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JS八股文自整合通俗易懂版下</div></div><div class="info-2"><div class="info-item-1">六、this&#x2F;call&#x2F;apply&#x2F;bind1. 对this对象的理解 this  指的是最后调用函数的那个对象，具体指向看调用方式：  函数调用（如  fn() ）： this  指向全局对象（浏览器里是  window ）。 方法调用（如  obj.fn() ）： this  指向调用方法的对象  obj 。 构造函数调用（如  new Fn() ）： this  指向新创建的实例对象。 call&#x2F;apply&#x2F;bind 调用： this  指向这三个方法第一个参数指定的对象。  优先级：构造函数调用 &gt; call&#x2F;apply&#x2F;bind &gt; 方法调用 &gt; 函数调用。 2. call() 和 apply() 的区别？两者都能改变  this  指向，区别仅在传参方式：  call(context, arg1, arg2, …) ：第一个参数是  this  指向，后面是逐个传入的参数。  apply(context, [arg1, arg2, …])...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/picture/touxiang.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">李贝贝</div><div class="author-info-description">小草正在长大~</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://haiyong.site/moyu/"><i class="iconfont icon-youxishoubing"></i><span>摸鱼</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"><b><font color="#e66b6d">我</font> <font color="#e66d98">热</font> <font color="#e66cc6">爱</font> <font color="#cc6de6">我</font> </b> <p align="center">QQ:3151897241</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">一、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaScript%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1. JavaScript有哪些数据类型，它们的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.</span> <span class="toc-text">2. 数据类型检测的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.</span> <span class="toc-text">3. 判断数组的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">4. null和undefined区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-typeof-null-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5. typeof null 的结果是什么，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-intanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text">6. intanceof 操作符的实现原理及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89"><span class="toc-number">1.7.</span> <span class="toc-text">7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-isNaN-%E5%92%8C-Number-isNaN-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">10. isNaN 和 Number.isNaN 函数的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">12. 其他值到字符串的转换规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E6%95%B0%E5%AD%97%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">13. 其他值到数字值的转换规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%85%B6%E4%BB%96%E5%80%BC%E5%88%B0%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">14. 其他值到布尔类型的值的转换规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Object-is-%E4%B8%8E%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">16. Object.is()与比较操作符 &#x3D;&#x3D;&#x3D;和&#x3D;&#x3D; 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-JavaScript-%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">18. JavaScript 中如何进行隐式类型转换？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ES6"><span class="toc-number">2.</span> <span class="toc-text">二、ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">1. let、const、var的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%90%97"><span class="toc-number">2.2.</span> <span class="toc-text">2. const对象的属性可以修改吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E6%9E%9Cnew%E4%B8%80%E4%B8%AA%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">2.3.</span> <span class="toc-text">3. 如果new一个箭头函数的会怎么样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4. 箭头函数与普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91%E5%93%AA%E2%BE%A5%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5. 箭头函数的this指向哪⾥？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AF%B9-rest-%E5%8F%82%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.6.</span> <span class="toc-text">10. 对 rest 参数的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-ES6%E4%B8%AD%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">11. ES6中模板语法与字符串处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81JavaScript%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">三、JavaScript基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">1. new操作符的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-map%E5%92%8CObject%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">2. map和Object的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JavaScript%E8%84%9A%E6%9C%AC%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">7. JavaScript脚本延迟加载的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JavaScript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">8. JavaScript 类数组对象的定义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">9. 数组有哪些原生方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E7%9A%84-arguments-%E5%8F%82%E6%95%B0%E6%98%AF%E7%B1%BB%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E7%B1%BB%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.</span> <span class="toc-text">12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF-DOM-%E5%92%8C-BOM%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">13. 什么是 DOM 和 BOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AF%B9%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84"><span class="toc-number">3.8.</span> <span class="toc-text">14. 对类数组对象的理解，如何转化为数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AF%B9AJAX%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAJAX%E8%AF%B7%E6%B1%82"><span class="toc-number">3.9.</span> <span class="toc-text">16. 对AJAX的理解，实现一个AJAX请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-JavaScript%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%8C%E5%AE%83%E5%AF%BC%E8%87%B4%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">17. JavaScript为什么要进行变量提升，它导致了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-ES6%E6%A8%A1%E5%9D%97%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">19. ES6模块与CommonJS模块有什么异同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">22. 如何判断一个对象是否属于某个类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-for%E2%80%A6in%E5%92%8Cfor%E2%80%A6of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.13.</span> <span class="toc-text">25. for…in和for…of的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.14.</span> <span class="toc-text">28. 数组的遍历方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-forEach%E5%92%8Cmap%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.15.</span> <span class="toc-text">29. forEach和map方法有什么区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">4.</span> <span class="toc-text">四、原型与原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">1. 对原型、原型链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E4%BF%AE%E6%94%B9%E3%80%81%E9%87%8D%E5%86%99"><span class="toc-number">4.2.</span> <span class="toc-text">2. 原型修改、重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%8C%87%E5%90%91"><span class="toc-number">4.3.</span> <span class="toc-text">3. 原型链指向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">五、执行上下文&#x2F;作用域链&#x2F;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">1. 对闭包的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">2. 对作用域、作用域链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">3. 对执行上下文的理解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/%E3%80%8A%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82Node.js%E3%80%81nvm%E3%80%81npm%E3%80%81npx%EF%BC%9A%E8%B0%81%E6%98%AF%E5%A4%A7%E5%8E%A8%EF%BC%9F%E8%B0%81%E6%98%AF%E8%B0%83%E5%BA%A6%E5%91%98%EF%BC%9F%E3%80%8B/" title="《一文看懂Node.js、nvm、npm、npx：谁是大厨？谁是调度员？》">《一文看懂Node.js、nvm、npm、npx：谁是大厨？谁是调度员？》</a><time datetime="2025-07-22T12:00:53.219Z" title="Created 2025-07-22 20:00:53">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/Vue%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8B/" title="Vue八股文自整合通俗易懂版下">Vue八股文自整合通俗易懂版下</a><time datetime="2025-07-22T12:00:41.774Z" title="Created 2025-07-22 20:00:41">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/Vue%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/" title="Vue八股文自整合通俗易懂版上">Vue八股文自整合通俗易懂版上</a><time datetime="2025-07-22T12:00:26.692Z" title="Created 2025-07-22 20:00:26">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8B/" title="JS八股文自整合通俗易懂版下">JS八股文自整合通俗易懂版下</a><time datetime="2025-07-22T12:00:13.444Z" title="Created 2025-07-22 20:00:13">2025-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/22/JS%E5%85%AB%E8%82%A1%E6%96%87%E8%87%AA%E6%95%B4%E5%90%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%89%88%E4%B8%8A/" title="JS八股文自整合通俗易懂版上">JS八股文自整合通俗易懂版上</a><time datetime="2025-07-22T12:00:05.913Z" title="Created 2025-07-22 20:00:05">2025-07-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By 李贝贝</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>